## Redis

### Redis是什么

Redis是C语言开发的一款开源的、高效的键值对的内存数据库，可以用作数据库，缓存，消息中间件等。

它是一种非关系型数据库

#### 五种数据类型

1. string类型

   > 最基本的数据类型，一个key对应一个value，value可以是数字或者是字符串

2. Hash类型

   > Hash是一个(key-value)的映射表，特别适合用来存储对象

3. List类型

   > List是一个简单的字符串列表，根据插入的对象排序，可以从左侧或者右侧插入，可以从左侧或者右侧取值

4. Set类型

   > Set类型是无序的且无重复的字符串列表，可以取两个Set的并集以及差集等

5. Zset类型

   > 与Set类型一样，只不过添加了一个score字段来排序，数据集内部元素会根据score字段排序

#### 缓存一致性问题

当我们查询数据，先去缓存中查，缓存中有的话直接拿缓存中的数据就好了。如果缓存中没有，那么就去数据库中查询，再讲数据插入缓存中。
在读数据时，是没有什么问题的，在写入数据时，并发情况下就会出现数据库与缓存一致性问题：

1. 如果先删除缓存再写库：线程A删除了缓存，去数据库写库，这时B来查询，发现缓存中没有，就去查询并且写入数据库，此时缓存中为脏数据。
2. 如果先写库，再更新缓存，在写库完成后，宕机了，数据库与缓存中的数据也不一致了。

##### 1. 延时双删策略

1. 先删除缓存
2. 再写库
3. 休眠一会儿
4. 再删除缓存

##### 2. 订阅binlog

我们设置所有的读操作都在Redis中进行
所有的写操作都在数据库中进行
程序读取mysql的binlog，得到增删改查操作，之后将操作添加进消息队列等，消费队列中的操作消息来进行缓存同步。

##### 3. 设置过期时间

设置过期时间，对数据同步是比较有利的，当key过期后，我们查询不到就会去查询数据库并更新到缓存中了。

#### 缓存雪崩

缓存中的key大面积过期，导致所有的请求都请求到了数据库上，大概率会造成数据库宕机。

##### 如何防止缓存雪崩

设置过期时间时不要都给相同的值。

#### 缓存穿透

当用户不停的去请求一个数据库与缓存中都没有的数据的时候，因为缓存中没有，所以会去数据库中查询，数据库中也没有，所以不会更新缓存，就会每次发都会去请求数据库。

##### 如何解决缓存穿透

在接口层设置校验，校验token，校验逻辑，如不符合的数据不能去缓存，还有一种布隆过滤器，它会判断数据库中是否有该数据。

#### 缓存击穿

缓存击穿是有一个热点数据，会被经常访问，在这个数据失效的瞬间，很多请求会到数据库请求。

##### 如何解决缓存击穿

设置热点数据永不过期，或者在Redis中查不到数据后，给去数据库查询的代码块或者方法上加互斥锁，避免过多请求到数据库。

#### Redis为什么这么快？为什么是单线程？

因为Redis是基于内存的，绝大部分请求完全是内存操作，数据存在内存中，查询修改特别快，使用单线程，避免了线程上下文切换，不存在CPU的调度，不用考虑锁的问题，使用多路复用IO。

#### 淘汰策略

| 策略            | 详细描述                                       |
| --------------- | ---------------------------------------------- |
| volatile-lru    | 从已设置过期时间的kv集中优先淘汰最少使用的     |
| volatile-ttl    | 从已设置过期时间的kv集中优先淘汰剩余时间最短的 |
| volatile-random | 从已设置过期时间的kv集中随机挑选淘汰的         |
| allkeys-lru     | 从所有kv集中优先淘汰最少使用的                 |
| allkeys-ttl     | 从所有kv集中淘汰剩余时间最短的                 |
| noeviction      | 不淘汰，如果超出内存限制则报错                 |
| volatile-lfu    | 对设置过期时间的访问频率最低的进行淘汰         |
| allkeys-lfu     | 对所有kv集中访问频率最低的进行淘汰             |

#### 持久化

持久化即将缓存中的数据写入硬盘中，即使重启或者断电，数据仍然存在。Redis会周期性的进行持久化。

##### RDB

快照形式，直接将Redis中的数据存储到一个RDB文件中，定时保存 
当需要进行备份时，Redis fork一个子进程来写入RDB文件，优点是数据恢复很快，缺点是可能会丢失一段时间的数据。

##### AOF

将Redis除读以外的操作命令记录到aof文件中，当进行恢复时，执行这些命令来进行恢复数据。每隔一秒或者短时间内进行写入，比RDB的数据更完整，但是AOF文件会大于RDB文件并且数据恢复慢，高频率的写入文件会造成CPU效率低。