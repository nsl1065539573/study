## TCP与UDP

### TCP三次握手与四次挥手

####  TCP三次握手过程

 1. 客户端发起连接请求，发送SYN以及自己的SEQ给服务端，进入SYN-SENT状态
 2. 服务端接收到请求后，发送SYN、ACK以及SEQ给客户端，进入SYN-REVD状态
 3. 客户端发送ACK给服务端，双方建立连接

#### 为什么需要进行三次握手

1. 为了双方初始化序列号

   > 序列号是保证TCP数据可靠传输的有力机制之一，有了序列号，我们可以在不稳定的网络中进行稳定的数据传输。它可以：
   >
   > - 重复数据包去重
   > - 数据包重排列
   > - 根据序列号进行数据的重传
   >
   > 第一次握手时客户端向服务端发送序列号，第二次握手时服务端发送序列号并且确认客户端序列号，第三次握手客户端确认服务端序列号

2. 为了避免过期连接

   > 服务端并不能判断当前连接是否是过期连接，所以在接收到连接请求后，返回ACK = SEQ + 1，由客户端判断是否是过期连接，如果是过期连接，则直接返回一个RST报文，如果是当前连接，则返回ACK

#### 为什么不是两次或者四次握手

##### 为什么不是两次

1. 避免过期连接

   > 如果建立连接只需要两次握手，那么当服务端收到一个网络中滞留的过期连接请求时，服务端返回客户端报文，此时服务端建立连接，但客户端不会理会服务端的报文，浪费服务器的资源

##### 为什么不是四次

​	可以使用三次连接，没有必要使用四次连接

#### TCP四次挥手过程

1. A端要断开连接，则向B端发送FIN报文，此时A端进入_FIN-WAIT-1_状态
2. B端接收到FIN后，向A端发送ACK报文，A端接收到ACK报文后进入_FIN-WAIT-2_状态，B端进入_CLOSE-WAIT_状态
3. B端发送FIN给A端，B端进入_LAST-ACK_状态
4. A端发送ACK给B端，进入_TIME-WAIT_状态，等待2MSL时间，B段接收到ACK

#### 如果B端没有收到ACK会发生什么

1. B端没有收到ACK，则会超时重传FIN，A端如果此时处于_TIME-WAIT_状态，那么就会重发这个ACK

2. B端没有收到ACK，超时重传FIN，A端此时已经关闭了，处于_CLOSED_状态，则会向B端发送一个RST报文，B端进入_CLOSED_状态

3. B端没有收到ACK，超时重传FIN，此时A端挂了，那么B端会一直超时重传，直到重传超时进入_CLOSED_状态

####   服务端发现大量的_CLOSE-WAIT_状态

代码中没有关闭连接，即没有发送FIN给A端

#### 为什么要等待2MSL时间

1. 如果最后一个ACK没有发送成功，则等待2MSL可以等待服务端的FIN
2. 可以使本次连接的数据全部消失

### TCP如何保证可靠连接

- 校验和

  > 计算方式：在发送数据时，将发送的数据段都当做一个16位的整数，将这些整数加起来，并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。
  >
  > 发送方：在发送数据之前计算校验和，填充在报文的校验和中
  >
  > 接收方：接收到数据后以同样的方式对数据进行运算得到校验和，计算与报文中的校验和是否相同

- 确认应答与序列号

  > TCP连接期间，报文发送都会带上当前数据包的序列号，接收方可以对数据进行去重，重排序以及校验是否丢包。
  >
  > 接收报文后需要发送 ACK = SEQ + 1 来确认应答，如果ACK不正确，发送数据端根据ACK进行数据重新发送

- 超时重传

  > 在发送数据后，可能没有等到接收方的ACK报文，此时可能有如下两种情况
  >
  > - 发送数据丢包，接收方没有收到报文
  > - 接收方的ACK丢包
  >
  > 在等待一段时间没有获得应答后，发送方就会重发这段报文，如果接收端没有接收到过这段报文，那么接收到到二次重发的报文后就会继续响应ACK
  >
  > 如果是接收端已经收到过报文了，也可以根据序列号进行去重

- 连接管理

  > 连接管理就是TCP的三次握手以及四次挥手，建立可靠地连接来保证可靠地数据传输

- 流量控制

  > 接收端在接收到报文后，需要对报文进行处理，如果发送的速度太快，就会造成接收方的缓冲区被填满而无法继续接收，之后就会触发超时重传等一系列机制。为了避免这个状况，TCP根据接收端的处理能力，引入了流量控制。
  >
  > 在TCP的报文头中，有一个窗口大小的字段，发送方可以根据获得的窗口大小来决定发送消息的速度。当窗口大小为0时，停止发送消息，但是会发送窗口探测报文来探测接收方是否可以进行接收。

- 拥塞控制

  > 拥塞控制指的是如果网络目前的情况比较差，那么一下发送很多数据会造成大量的丢包，引发超时重传等，所以TCP引入了慢启动的机制，再开始发送数据时，先发送少量的数据来探路，探清当前的网络状态，再决定以多大的速度进行传输，于是引入了拥塞窗口的概念。
  >
  > 发送刚开始时定义拥塞窗口大小为1，每次收到ACK应答，拥塞窗口翻倍。在发送数据之前，要用拥塞窗口和接收方的窗口大小比较，取较小值作为实际发送的窗口大小。
  >
  > 慢开始只是说一开始时传输快，但实际上增长的特别快，所以我们设置阈值，当超过阈值时，每收到应答后窗口数加一，当网络拥塞后，设置新的阈值为当前窗口数的一半，同时窗口大小置为1,。
  >
  > 快重传：连续收到三个ACK后，即进入快重传，即上面说的重置阈值，窗口设置为1
  >
  > 快启动：如果我们收到三个ACK后将窗口设置为1就有点反应强烈了，我们可以将窗口大小设置为新的阈值，之后线性增长即可。

### UDP

#### UDP协议的特点

- 面向无连接的

  > 不需要建立连接就能传输数据，只需要知道对端的IP以及端口号

- 面向报文

  > 应用交给UDP什么报文，UDP既不拆分，也不会合并，而是会原样发送

- 不可靠传输

  > 没有确认机制，没有重传机制，数据丢了也不会给协议层信息返回任何错误信息。

### HTTP与HTTPS

#### HTTPS建立连接过程

1. 客户端与服务端通过TCP三次握手建立连接
2. 客户端向服务端发送自己支持的加密协议以及版本
3. 服务端选择出合适的加密算法，向客户端发送数字证书，证书中包括服务端的公钥，hash算法、握手信息等
4. 客户端验证证书，如果没问题则继续流程，有问题则弹出提示，该证书不受信任
5. 客户端生成随机数，用服务端发来的公钥进行加密
6. 用证书中的hash算法取握手信息的hash值，使用随机数加密握手信息以及握手信息的hash值，然后使用公钥将随机数加密，一并发送给服务端
7. 服务端得到加密的随机数，解密得到随机数，使用随机数解密握手信息以及握手的hash值，验证握手信息，验证无误用同样的随机数发送握手信息以及握手信息的hash值给客户端
8. 客户端验证握手信息以及握手信息的hash值，无误后建立连接

#### 浏览器中输入URL后并访问主页发生了什么

1. 域名解析获得IP地址和端口号

   > 浏览器本地缓存 => 操作系统hosts => DNS服务器

2. 根据IP地址和端口号与服务器建立TCP连接

   > 三次握手

3. 建立连接后，向服务器发送请求资源的请求

4. 服务器接收到请求后，根据路由信息进行相应的处理，并向浏览器返回

5. 双方某一方关闭连接

   > 四次挥手

6. 浏览器解析文件并渲染

#### GET与POST的区别

1. GET方法在HTTP协议用于查询，POST用于更新
2. GET请求时通过URL直接请求数据，数据信息放在URL中，POST请求的数据放在BODY体中
3. GET请求其实没有长度，因为http协议对此并没有规定URL长度，但是不同的浏览器对URL长度有规定；POST的数据长度受限于服务器的处理能力
4. 查询信息常用GET，增删改的时候使用POST

#### URL各部分详解

以http://127.0.0.1:8080/demo/demo.jsp?id=5&p=3为例：

> http：协议名
>
> 127.0.0.1：IP地址
>
> 8080：端口号   可以使用域名来代替IP地址和端口号
>
> demo：端口或者域名后面的第一个'/'到最后一个'/'之间的就是虚拟目录
>
> demo.jsp：请求的资源文件名
>
> id = 5 & p = 3：参数，后台可以解析参数
>
> #point 根据name或者id界面将定位到div